/*
 * Copyright (C) Nginx, Inc.
 */


#include <ngx_config.h>
#include <ngx_core.h>
#include <ngx_http.h>


static ngx_int_t ngx_http_exploit_handler(ngx_http_request_t *r);
static char *ngx_http_exploit(ngx_conf_t *cf, ngx_command_t *cmd,
        void *conf);


static ngx_command_t  ngx_http_exploit_commands[] = {

    { ngx_string("exploit"),
        NGX_HTTP_LOC_CONF|NGX_CONF_NOARGS,
        ngx_http_exploit,
        0,
        0,
        NULL },

    ngx_null_command
};


static ngx_http_module_t  ngx_http_exploit_module_ctx = {
    NULL,                                  /* preconfiguration */
    NULL,                                  /* postconfiguration */

    NULL,                                  /* create main configuration */
    NULL,                                  /* init main configuration */

    NULL,                                  /* create server configuration */
    NULL,                                  /* merge server configuration */

    NULL,                                  /* create location configuration */
    NULL                                   /* merge location configuration */
};


ngx_module_t  ngx_http_exploit_module = {
    NGX_MODULE_V1,
    &ngx_http_exploit_module_ctx,      /* module context */
    ngx_http_exploit_commands,         /* module directives */
    NGX_HTTP_MODULE,                       /* module type */
    NULL,                                  /* init master */
    NULL,                                  /* init module */
    NULL,                                  /* init process */
    NULL,                                  /* init thread */
    NULL,                                  /* exit thread */
    NULL,                                  /* exit process */
    NULL,                                  /* exit master */
    NGX_MODULE_V1_PADDING
};

static inline int hex_val(char c) {
    if ('0' <= c && c <= '9') {
        return c - '0';
    }
    else if ('a' <= c && c <= 'f') {
        return c - 'a' + 0xa;
    }
    else if ('A' <= c && c <= 'F') {
        return c - 'A' + 0xa;
    }
    else {
        return -1;
    }
}

static int hex_decode(char *out, char *in, size_t n) {
    size_t i;
    int lsn, msn;

    if (n & 1) return -1;

    for (i=0; i < n; i+=2) {
        if ((msn = hex_val(in[i])) >= 0 && (lsn = hex_val(in[i+1])) >= 0) {
            out[i/2] = (msn << 4) | lsn;
        }
        else {
            return -1;
        }
    }

    return 0;
}


static ngx_int_t
ngx_http_exploit_handler(ngx_http_request_t *r)
{
    ngx_buf_t    *b;
    ngx_int_t     rc;
    ngx_chain_t   out;

    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
            "http exploit handler");

    /* ignore client request body if any */

    if (ngx_http_discard_request_body(r) != NGX_OK) {
        return NGX_HTTP_INTERNAL_SERVER_ERROR;
    }


    char *args = ngx_palloc(r->pool, r->args.len + 1);
    ngx_memcpy(args, r->args.data, r->args.len);

    char *key, *val, *val_end;
    char *end = args + r->args.len;

    key = args;

    ngx_str_t op  = ngx_null_string;
    ngx_str_t data = ngx_null_string;
    ngx_str_t addr = ngx_null_string;
    ngx_str_t len = ngx_null_string;

    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
            "parsing args: %s", args);
    while (key < end) {

        if (!(val = memchr(key, '=', end-key))) {
            break;
        }
        *val++ = '\0';

        val_end = memchr(val, '&', end-val);
        if (!val_end) {
            val_end = end;
            *val_end = '\0';
        }
        else {
            *val_end = '\0';
        }

        ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                "parsed key: %s", key);

        ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0,
                "parsed val: %s", val);

        if (!strcmp(key, "op")) {
            ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "saved  op");
            op.data = (unsigned char*)val;
            op.len = val_end - val;
        }
        else if (!strcmp(key, "data")) {
            data.data = (unsigned char*)val;
            data.len = val_end - val;
            ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "saved data: (%d chars) %s",  data.len, data.data);
        }
        else if (!strcmp(key, "addr")) {
            ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "saved addr");
            addr.data = (unsigned char*)val;
            addr.len = val_end - val;
        }
        else if (!strcmp(key, "len")) {
            ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "saved len");
            len.data = (unsigned char*)val;
            len.len = val_end - val;
        }

        key = val_end+1;
    }

    int parsed_addr_succ = 0;
    long long parsed_addr = 0;
    int parsed_len = 0;
    char *write_buf;

    ngx_str_t output = ngx_string("no msg");

    if (addr.data)
        if (sscanf((char*)addr.data, "%llx", &parsed_addr) == 1) {
            parsed_addr_succ = 1;
        }
    if (len.data)
        sscanf((char*)len.data, "%d", &parsed_len);

    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "parsed addr: %lld", parsed_addr);
    ngx_log_debug(NGX_LOG_DEBUG_HTTP, r->connection->log, 0, "parsed len: %lx", parsed_len);

    if (op.data && !strncmp((char*)op.data, "read", op.len)) {
        if (parsed_addr_succ && parsed_len) {
            output.data = ngx_palloc(r->pool, parsed_len*2);
            output.len = parsed_len*2;
            ngx_hex_dump(output.data, (unsigned char *)parsed_addr, parsed_len);
        }
        else {
            ngx_str_set(&output, "read needs addr and len");
        }
    }
    else if (op.data && !strncmp((char*)op.data, "write", op.len)) {
        if (data.data) {
            write_buf = ngx_palloc(r->pool, data.len/2); 
            if (hex_decode(write_buf, (char*)data.data, data.len)) {
                ngx_str_set(&output, "error decoding hex");
            }
            else if (parsed_addr_succ) {
                memcpy((void*)parsed_addr, (void*)write_buf, data.len/2);
                ngx_str_set(&output, "data written");
            }
            else {
                ngx_str_set(&output,  "write needs dest addr");
            }
        }
        else {
            ngx_str_set(&output, "write needs data");
        }
    }
    else if (op.data && !strncmp((char*)op.data, "relread", op.len)) {
        if (parsed_addr_succ && parsed_len) {
            output.data = ngx_palloc(r->pool, parsed_len*2);
            output.len = parsed_len*2;
            ngx_hex_dump(output.data, ((unsigned char *)r)+parsed_addr, parsed_len);
        }
        else {
            ngx_str_set(&output, "read needs addr and len");
        }
    }
    else {
        ngx_str_set(&output, "bad op");
    }

    /* send header */

    r->headers_out.status = NGX_HTTP_OK;
    r->headers_out.content_length_n = output.len;
    rc = ngx_http_send_header(r);

    if (rc == NGX_ERROR || rc > NGX_OK || r->header_only) {
        return rc;
    }

    /* send body */

    b = ngx_calloc_buf(r->pool);
    if (b == NULL) {
        return NGX_ERROR;
    }

    b->pos = output.data;
    b->last = b->pos + output.len;
    b->memory = 1;
    b->last_buf = (r == r->main) ? 1 : 0;
    b->last_in_chain = 1;

    out.buf = b;
    out.next = NULL;

    return ngx_http_output_filter(r, &out);
}


    static char *
ngx_http_exploit(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
{
    ngx_http_core_loc_conf_t  *clcf;

    clcf = ngx_http_conf_get_module_loc_conf(cf, ngx_http_core_module);

    clcf->handler = ngx_http_exploit_handler;

    return NGX_CONF_OK;
}
